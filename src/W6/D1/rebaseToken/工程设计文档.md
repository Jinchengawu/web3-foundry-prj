# 通缩型Token (Rebase Token) 工程设计文档

## 1. 项目概述

### 1.1 项目目标
实现一个通缩型ERC20 Token，通过rebase机制实现每年1%的通缩，理解rebase型Token的核心实现原理。

### 1.2 核心特性
- 起始发行量：1亿枚
- 通缩机制：每年在上一年的基础上下降1%
- 实时余额显示：`balanceOf()` 方法正确反映通缩后的用户余额
- 完全兼容ERC20标准

## 2. 技术架构设计

### 2.1 核心概念
**Rebase机制原理：**
- 不改变用户持有的Token数量
- 通过调整总供应量实现通缩效果
- 用户余额比例保持不变，但实际价值增加

### 2.2 数据结构设计

```solidity
struct RebaseInfo {
    uint256 totalSupply;      // 当前总供应量
    uint256 rebaseIndex;      // rebase指数 (精度: 1e18)
    uint256 lastRebaseTime;   // 上次rebase时间
    uint256 annualDeflation;  // 年通缩率 (1% = 100)
}
```

### 2.3 核心变量
- `_totalSupply`: 当前总供应量
- `_rebaseIndex`: rebase指数，用于计算实际余额
- `_balances`: 用户原始余额映射
- `_lastRebaseTime`: 上次rebase时间戳
- `_annualDeflation`: 年通缩率 (1% = 100)

## 3. 核心算法设计

### 3.1 Rebase指数计算
```
rebaseIndex = previousIndex * (1 - annualDeflation / 10000)
```

### 3.2 余额计算
```
实际余额 = 原始余额 * rebaseIndex / 1e18
```

### 3.3 转账计算
```
转账金额 = 实际转账数量 * 1e18 / rebaseIndex
```

## 4. 功能模块设计

### 4.1 初始化模块
- 设置初始总供应量：1亿枚
- 初始化rebase指数：1e18
- 设置年通缩率：1%
- 记录部署时间

### 4.2 Rebase执行模块
- 检查是否满足rebase条件（时间间隔）
- 计算新的rebase指数
- 更新总供应量
- 记录rebase事件

### 4.3 余额查询模块
- `balanceOf()`: 返回用户实际余额
- `totalSupply()`: 返回当前总供应量
- `getRebaseIndex()`: 返回当前rebase指数

### 4.4 转账模块
- `transfer()`: 标准ERC20转账
- `transferFrom()`: 授权转账
- 自动处理rebase指数转换

## 5. 接口设计

### 5.1 公共接口
```solidity
// 查询接口
function balanceOf(address account) external view returns (uint256);
function totalSupply() external view returns (uint256);
function getRebaseIndex() external view returns (uint256);
function getLastRebaseTime() external view returns (uint256);

// 操作接口
function rebase() external;
function transfer(address to, uint256 amount) external returns (bool);
function transferFrom(address from, address to, uint256 amount) external returns (bool);
function approve(address spender, uint256 amount) external returns (bool);
```

### 5.2 事件定义
```solidity
event Rebase(uint256 indexed timestamp, uint256 oldIndex, uint256 newIndex, uint256 oldSupply, uint256 newSupply);
event Transfer(address indexed from, address indexed to, uint256 value);
event Approval(address indexed owner, address indexed spender, uint256 value);
```

## 6. 安全考虑

### 6.1 权限控制
- 只有合约所有者可以执行rebase操作
- 防止频繁rebase攻击

### 6.2 数值安全
- 使用SafeMath库防止溢出
- 精确的数学计算避免精度损失
- 合理的rebase时间间隔控制

### 6.3 重入攻击防护
- 使用ReentrancyGuard
- 状态更新在外部调用之前

## 7. 测试策略

### 7.1 单元测试
- 初始化测试：验证初始状态
- Rebase功能测试：验证通缩计算
- 余额计算测试：验证balanceOf()正确性
- 转账测试：验证转账功能

### 7.2 集成测试
- 多用户场景测试
- 长时间运行测试
- 边界条件测试

### 7.3 测试用例
```solidity
// 测试场景1：初始状态验证
- 总供应量 = 100,000,000
- rebase指数 = 1e18
- 用户余额显示正确

// 测试场景2：首次rebase
- 执行rebase后总供应量减少1%
- rebase指数相应调整
- 用户余额比例保持不变

// 测试场景3：多次rebase
- 连续执行多次rebase
- 验证复合通缩效果
- 确保计算精度

// 测试场景4：转账测试
- rebase前后转账功能正常
- 余额计算准确
- 事件正确触发
```

## 8. 部署配置

### 8.1 网络配置
- 测试网：Sepolia
- 主网：Ethereum Mainnet

### 8.2 部署参数
- 初始总供应量：100,000,000
- 年通缩率：1% (100)
- 最小rebase间隔：1天
- 精度：18位小数

## 9. 监控和维护

### 9.1 关键指标监控
- Rebase执行频率
- 总供应量变化趋势
- 用户余额变化
- Gas消耗情况

### 9.2 维护计划
- 定期检查rebase执行情况
- 监控异常交易
- 更新安全参数

## 10. 文档和说明

### 10.1 用户指南
- Token使用说明
- Rebase机制解释
- 余额查询方法

### 10.2 开发者文档
- 合约接口说明
- 集成指南
- 测试方法

## 11. 风险评估

### 11.1 技术风险
- 数学计算精度问题
- Gas消耗过高
- 智能合约漏洞

### 11.2 业务风险
- 用户理解困难
- 市场接受度
- 监管合规问题

## 12. 后续优化

### 12.1 功能扩展
- 动态通缩率调整
- 多级权限管理
- 治理机制集成

### 12.2 性能优化
- Gas优化
- 批量操作支持
- 缓存机制

---

**文档版本：** v1.0  
**创建日期：** 2025-01-13  
**最后更新：** 2025-01-13  
**负责人：** 开发团队 